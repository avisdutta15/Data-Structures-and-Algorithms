# BFS 
## Psuedocode

Code: Adjacency List Representation
<pre>
<code>
class Solution {
  public:
    vector<int> bfs(vector<vector<int>> &adjList) {
        if(adjList.size() == 0)
            return vector<int>();
            
        
        int V = adjList.size();
        vector<bool> visited (V, false);
        queue<int> Q;
        vector<int> traversal;
        
        //visit the start node 
        Q.push(0);
        visited[0] = true;

        while(!Q.empty()){
            //Pop
            int u = Q.front();
            Q.pop();
            
            //Process
            traversal.push_back(u);
            
            //Traverse unvisited neighbours
            for(auto v: adjList[u]){
                if(visited[v] == false){
                    visited[v] = true;
                    Q.push(v);
                }
            }
        }
        
        return traversal;
    }
};
</code>
</pre>

Code: Adjacency Matrix Representation 

## Visualization

![alt text](../assets/image.png)
![alt text](../assets/image-1.png)
![alt text](../assets/image-2.png)
![alt text](../assets/image-3.png)
![alt text](../assets/image-4.png)
![alt text](../assets/image-5.png)
![alt text](../assets/image-6.png)
![alt text](../assets/image-7.png)

## Time Complexity
Let's first look at the pseudo code to understand the time complexity

<pre>
<code>
BFS(graph, Node):
    create an empty queue Q                 - O(1)
    create a visited set                    - O(V)
    enqueue Node and mark as visited        - O(1)

    while Q is not empty:                   - O(V)
        node = dequeue from Q               - O(1)
        process(node)                       - O(1)

        for each neighbor of node:          - O(E)
            if neighbor is not visited:     - O(1)
                enqueue neighbor to Q       - O(1)
                mark neighbor as visited    - O(1)
</code>
</pre>

At first glance, the structure of a typical BFS implementation — with an outer while loop to process nodes from the queue and an inner for loop to examine all adjacent neighbors—might suggest a nested loop behavior, which some could mistakenly interpret as having a higher time complexity. However, the key point is that the apparent nesting does not multiply the time by V and E independently. Here’s why:

<li> <b>Outer While Loop – Node Processing:</b> The while loop runs as long as there are nodes in the queue. Since each node is enqueued only once (tracked by the visited array), the loop executes once for each node, meaning it runs a total of V times (where V is the number of vertices). Each node is processed exactly once when it is dequeued, so the total time in the while loop is proportional to the number of nodes, i.e., O(V).
<li> <b>Inner For Loop – Edge Processing:</b> In each iteration of the while loop, the for loop processes the neighbors of the current node. Each edge is examined once across all iterations, making the total edge processing proportional to E. In an undirected graph, edges are counted twice (once for each endpoint), but this does not affect the overall complexity. Therefore, the edge processing is O(E).

<br><b>Putting It All Together</b>:

<li> <b>Node Work</b>: The total time in processing nodes is proportional to V since each node is visited exactly once in the outer while loop.
<li> <b>Edge Work</b>: The total time in processing edges (neighbors of nodes) is proportional to E, as each edge is examined exactly once in the inner for loop, during its first encounter.
Therefore, even though the algorithm has a nested while and for loop structure, the total work is determined by the number of nodes and edges. The time complexity of the traversal is <b>O(V + E)</b>, which holds for the best, average, and worst cases.

## Space Complexity

<b>Auxiliary Space of Breadth First Search (BFS):</b>
The auxiliary space complexity of Breadth-First Search algorithm is <b>O(V)</b>, where V is the number of vertices in the graph. Here's why the auxiliary space complexity is O(V):

<li><b>Queue Data Structure:</b> BFS typically uses a queue to keep track of the vertices to visit. At most, the queue will contain all vertices reachable from the starting vertex. Since the maximum number of vertices in the queue is bounded by the number of vertices in the graph, the space complexity of the queue is O(V).
<li><b>Visited Array:</b> BFS often employs a visited array to keep track of visited vertices to avoid revisiting them. This array has a size equal to the number of vertices in the graph, contributing to an auxiliary space complexity of O(V).

Additional Space:

While traversing the graph, BFS may use other auxiliary data structures or variables.
However, the space required by these additional elements is typically minimal compared to the queue and visited array and does not significantly affect the overall space complexity.
Therefore, the auxiliary space complexity of the Breadth-First Search algorithm is dominated by the queue and visited array, both of which require O(V) space, making the overall space complexity O(V).






# DFS
## Psuedocode
Code: Adjacency List Representation
<pre>
<code>
class Solution {
private:
    void dfsUtil(vector<vector<int>>& adj, int u, vector<bool> &visited, vector<int> &traversal){
        visited[u] = true;
        traversal.push_back(u);
        for(int v : adj[u]){
            if(visited[v] == false)
                dfsUtil(adj, v, visited, traversal);
        }
    }
public:
    vector<int> dfs(vector<vector<int>>& adj) {
        int V = adj.size();
        vector<bool> visited(V, false);
        int u = 0;
        
        vector<int> traversal;
        
        dfsUtil(adj, u, visited, traversal);
        return traversal;
    }
};
</code>
</pre>

## Visualization

![alt text](../assets/image-8.png) 
![alt text](../assets/image-9.png)
![alt text](../assets/image-10.png)
![alt text](../assets/image-11.png)
![alt text](../assets/image-12.png)
![alt text](../assets/image-13.png)
![alt text](../assets/image-14.png)
![alt text](../assets/image-15.png)

## Time Complexity
Let's first look at the pseudo code to understand the time complexity

<pre>
<code>
DFS(graph, root):
    create a visited set                            - O(V)
    call DFS-Visit(graph, root, visited)

DFS-Visit(graph, node, visited):
    mark node as visited                            - O(1)
    process(node)                                   - O(1)

    for each neighbor of node in graph:             - O(E)
        if neighbor is not visited:                 - O(1)
            DFS-Visit(graph, neighbor, visited)     - O(1)
</code>
</pre>

In DFS, we explore the graph by recursively visiting nodes. The process involves two key steps: visiting nodes and exploring their neighbors. Here’s how the time complexity works:

<b>Node Processing – Recursive Calls:</b>

<li>In the DFS-Visit function, each node is visited exactly once.
<li>The recursive calls ensure that every node is processed exactly once, so the total time in processing the nodes is proportional to the number of nodes, V, i.e., <b>O(V).</b>

</br>

<b>Edge Processing – Exploring Neighbors:</b>

<li>Within DFS-Visit, for each node, we explore all of its neighbors (adjacent vertices).
<li>Each edge is examined once when traversing from one node to its neighbor. In an undirected graph, each edge is checked twice (once for each endpoint), but this constant factor does not affect the overall complexity.
<li>Therefore, the total time in processing the edges is proportional to the number of edges, E, i.e., <b>O(E).</b>


Putting It All Together:

<li><b>Node Work: </b>The time in processing nodes is <b>O(V)</b>, as each node is visited exactly once.
<li><b>Edge Work: </b>The time in processing edges is <b>O(E)</b>, as each edge is explored once.

</br>
Thus, the overall time complexity of DFS traversal is O(V + E), which applies in all cases (best, average, and worst).


## Space Complexity
The auxiliary space of Depth-First Search (DFS) algorithm is <b>O(V)</b>, where V is the number of vertices in the graph, this is due to the recursion stack or visited array.

Here's why the auxiliary space complexity is O(V):

<li><b>Recursion Stack:</b>

DFS uses a function call stack to track vertices.
Space complexity depends on the maximum recursion depth.
Maximum depth in a graph with V vertices is O(V).

<li><b>Visited Array:</b>

Uses a visited array to mark visited vertices.
Size equals the number of vertices (V).

Therefore, the auxiliary space complexity of DFS is dominated by the recursion stack and the visited array, both of which require O(V) space, making the overall space complexity O(V).


# TODO
1. Adjacency Matrix Representation traversal of Graph using BFS and DFS
2. Iterative traversal of DFS