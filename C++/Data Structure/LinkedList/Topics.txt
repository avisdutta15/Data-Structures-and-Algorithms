1. Insertion, Deletion, Search, Rotate, Nth node from end.
2. Delete Problems
	A. Delete a LL
	B. Delete Alternate Nodes
	C. Delete Nodes which have greater value on right
	D. Delete N nodes after M nodes [IMP]
	E. Delete Last occurance of an element
	F. Remove duplicate elements from sorted (I/II)/unsorted linked list
	G. Delete a node in linked list when you are not passed the pointer to pointer to head i.e. (**head) and it should not return any pointer.
		To handle the case when the node to be deleted is the first node, we copy the next node data to head and delete the next node.
3. Cycle Detection, Finding the first node of the cycle, Remove loop
4. Is Linked List pallindrome.
5. Odd Even List
   Segregate odd and even positioned nodes
   Partition List
6. Reverse Problems
	A. Iterative reverse
	B. Recursive reverse

	   reverse(current):
		if(current->next == NULL) //make last node as head node
			head = current;
			return;
		reverse(current->next);
		current->next->next = current;
		current->next = NULL;
	C. Reverse List between index i and j.
	D. Reverse a Linked List in groups of given size
	E. Reverse alternate K nodes in a Singly Linked List 
	F. Print Immutable Linked List in Reverse
	G. Reverse Nodes in Even Length Groups
7. Add two numbers represented by linked lists
   Add two numbers represented by linked lists (II)
   Mulitply two numbers represented by linked lists
8. Clone a Linked List with random pointer (V VIP)
	App1: Use Hash table
		HashTable (oldNode, corrsponding newNode)
		travese the linked list
			find the old node, check its random node through list
			find the random node in the hash table. join Hash[OldNode]->random = Hash[OldNode->random]

	App2: Inserting new nodes in between
		
		

9. Find a triplet from three linked lists with sum equal to a given number
10. MergeSort Problems
	A. MergeSort
	B. Sort linked list which is already sorted on absolute values
	   An important observation is, all negative elements are present in reverse order. 
	   So we traverse the list, whenever we find an element that is out of order, we move it to the front of linked list.
	C. Point to next higher value node in a linked list with an arbitrary pointer (TODO)
11. Swap problems
	A. Swap nodes in a linked list without swapping data
	B. Pairwise swap elements of a given linked list by changing links (TODO) [Swap nodes in pair]
12. Sorting
	A. Bubble Sort
	B. Insertion Sort
	C. Merge Sort
	D. Quick Sort
	E. Merge two sorted linked lists such that the resultant list is in reverse order
	F. Sort a Linked List of 0s, 1s and 2s.
	G. Rearrange list in zig zag fashion (TODO)
	H. Sort a linked list that is sorted alternating ascending and descending orders (TODO)
13. Convert a binary tree to DLL		|
14. Convert a DLL to Binary Tree		|	Very Very Important	
	Convert Sorted List to Binary Search Tree
	Convert BST to Sorted DLL
15. Find the N/K the node and squareRoot(n)th node.
16. Find the modulo node
17. Length of longest palindrome list in a linked list using O(1) extra space
18. Partitioning a linked list around a given value and keeping the original order
19. Rearrange a given list such that it consists of alternating minimum maximum elements
20. Flatten a multi-level linked list and its variations:
	1. Flatten a linked list and the output should be in sorted order
	Node *flatten(Node *head){
    		if(head==NULL || head->right==NULL)
        		return head;
     		return merge(head, flatten(head->right));
	}
	2. Flatten a multilevel linked list (level wise)
	3. Flatten a multilevel linked list (depth wise)
	4. Flatten Binary Tree to Linked List
	5. Flatten a Multilevel DLL
21. Josephus Circle using circular linked list
22. Construct a linked list from 2D matrix
23. Merge two Linked Lists:
	Node* merge(Node *list1, Node *list2)
		if(list1==NULL)	return list2;
		if(list2==NULL) return list1;
		
		if(list1->data <= list2->data)
			list1->next = merge(list1->next, list2);
			return list1;
		else
			list2->next = merge(list1, list2->next);
			return list2;
	Merge K sorted Lists

24. Intersection of two Linked Lists - Solve this without finding the length of the lists
25. LRU Cache
    LFU Cache
26. Reorder List
27. Populating Next Right Pointers in each Node.
28. Populating Next Right Pointers in each Node II.
29. Insertion Sort List
30. Sort List
31. Design Twitter
32. Plus One Linked List
33. Design Phone Directory
34. Linked List Random Node
35. All O(1) Data Structure
36. Design Circular Queue
37. Design HashSet
38. Design HashMap
39. Design LinkedList
40. Insert into Sorted Circular Linked List
41. Max Stack
42. Split Linked Lists into Parts
43. Linked List components
44. Next Greater Node in Linked List
45. Remove Zero Sum Consequtive nodes
46. Design Skiplist
47. Convert Binary Number in Linked List to Integer
48. Linked List in Binary Tree
49. Design Browser History
50. Add Two Polynomials represented as Linked Lists
51. Merge In between Linked Lists
52. Design Front Middle Back Queue
53. Swapping Nodes in Linked List
54. Design Most Recently used Queue
55. Design Text Editor
56. Spiral Matrix IV
57. Split a Circular Linked List.
58. Double a Number represented as Linked List
59. Convert DLL to Array I/II
60. Minimum Pair Removal to Sort Array I/II
