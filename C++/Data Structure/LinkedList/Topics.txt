1. Insertion, Deletion, Search, Rotate, Nth node from end.
2. Delete Problems
	A. Delete a LL
	B. Delete Alternate Nodes
	C. Delete Nodes which have greater value on right
	D. Delete N nodes after M nodes [IMP]
	E. Delete Last occurance of an element
	F. Remove duplicate elements from sorted/unsorted linked list
	G. Delete a node in linked list when you are not passed the pointer to pointer to head i.e. (**head) and it should not return any pointer.
		To handle the case when the node to be deleted is the first node, we copy the next node data to head and delete the next node.
3. Cycle Detection, Finding the first node of the cycle, Remove loop
4. Is Linked List pallindrome.
5. Segregate odd and even positioned nodes
6. Reverse Problems
	A. Iterative reverse
	B. Recursive reverse

	   reverse(current):
		if(current->next == NULL) //make last node as head node
			head = current;
			return;
		reverse(current->next);
		current->next->next = current;
		current->next = NULL;

	C. Reverse a Linked List in groups of given size
	D. Reverse alternate K nodes in a Singly Linked List 
7. Add two numbers represented by linked lists
   Mylitply two numbers represented by linked lists
8. Clone a Linked List with random pointer (V VIP)
	App1: Use Hash table
		HashTable (oldNode, corrsponding newNode)
		travese the linked list
			find the old node, check its random node through list
			find the random node in the hash table. join Hash[OldNode]->random = Hash[OldNode->random]

	App2: Inserting new nodes in between
		
		

9. Find a triplet from three linked lists with sum equal to a given number
10. MergeSort Problems
	A. MergeSort
	B. Sort linked list which is already sorted on absolute values
	   An important observation is, all negative elements are present in reverse order. 
	   So we traverse the list, whenever we find an element that is out of order, we move it to the front of linked list.
	C. Point to next higher value node in a linked list with an arbitrary pointer (TODO)
11. Swap problems
	A. Swap nodes in a linked list without swapping data
	B. Pairwise swap elements of a given linked list by changing links (TODO)
12. Sorting
	A. Bubble Sort
	B. Insertion Sort
	C. Merge Sort
	D. Quick Sort
	E. Merge two sorted linked lists such that the resultant list is in reverse order
	F. Sort a Linked List of 0s, 1s and 2s.
	G. Rearrange list in zig zag fashion (TODO)
	H. Sort a linked list that is sorted alternating ascending and descending orders (TODO)
13. Convert a binary tree to DLL		|
14. Convert a DLL to Binary Tree		|	Very Very Important	
15. Find the N/K the node and squareRoot(n)th node.
16. Find the modulo node
17. Length of longest palindrome list in a linked list using O(1) extra space
18. Partitioning a linked list around a given value and keeping the original order
19. Rearrange a given list such that it consists of alternating minimum maximum elements
20. Flatten a multi-level linked list and its variations:
	1. Flatten a linked list and the output should be in sorted order
	Node *flatten(Node *head){
    		if(head==NULL || head->right==NULL)
        		return head;
     		return merge(head, flatten(head->right));
	}
	2. Flatten a multilevel linked list (level wise)
	3. Flatten a multilevel linked list (depth wise)
21. Josephus Circle using circular linked list
22. Construct a linked list from 2D matrix
23. Merge two Linked Lists:
	Node* merge(Node *list1, Node *list2)
		if(list1==NULL)	return list2;
		if(list2==NULL) return list1;
		
		if(list1->data <= list2->data)
			list1->next = merge(list1->next, list2);
			return list1;
		else
			list2->next = merge(list1, list2->next);
			return list2;

24. Intersection of two Linked Lists - Solve this without finding the length of the lists