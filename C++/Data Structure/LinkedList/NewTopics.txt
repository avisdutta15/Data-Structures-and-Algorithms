1. Insertion, Deletion, Search, Rotate, Nth node from end.
2. Delete Problems
3.      Delete a LL
4.      Delete Alternate Nodes
5.      Delete Nodes which have greater value on right
6.      Delete N nodes after M nodes [IMP]
7.      Delete Last occurance of an element
8.      Remove duplicate elements from sorted (I/II)/unsorted linked list
9.      Delete a node in linked list when you are not passed the pointer to pointer to head i.e. (**head) and it should not return any pointer.
		    To handle the case when the node to be deleted is the first node, we copy the next node data to head and delete the next node.
10. Cycle Detection, Finding the first node of the cycle, Remove loop
11. Is Linked List pallindrome.
12. Odd Even List
13. Segregate odd and even positioned nodes
14. Partition List [TODO]
15. Reverse Problems
16.     Iterative reverse
17.     Recursive reverse
    	    reverse(current):
	        	if(current->next == NULL) //make last node as head node
			    head = current;
			    return;
		    reverse(current->next);
		    current->next->next = current;
		    current->next = NULL;
18.     Reverse List between index i and j.
19.     Reverse a Linked List in groups of given size [TODO]
20.     Reverse alternate K nodes in a Singly Linked List [TODO]
21.     Print Immutable Linked List in Reverse [TODO]
22.     Reverse Nodes in Even Length Groups [TODO]
23. Add two numbers represented by linked lists
24. Add two numbers represented by linked lists (II)
25. Mulitply two numbers represented by linked lists [TODO]
26. Clone a Linked List with random pointer (V VIP)
	    App1: Use Hash table
		HashTable (oldNode, corrsponding newNode)
		travese the linked list
			find the old node, check its random node through list
			find the random node in the hash table. join Hash[OldNode]->random = Hash[OldNode->random]

	    App2: Inserting new nodes in between
27. LinkedList Random Node (https://www.youtube.com/watch?v=FoHIX3URFaM) [TODO]
28. MergeSort Problems
29.     Merge Two Sorted Linked Lists
30.     Merge K Sorted Lists
31.     MergeSort    
32.     Find a triplet from three linked lists with sum equal to a given number   
33.     Sort linked list which is already sorted on absolute values [TODO] 
	        An important observation is, all negative elements are present in reverse order. 
	        So we traverse the list, whenever we find an element that is out of order, we move it to the front of linked list.
34.     Point to next higher value node in a linked list with an arbitrary pointer
33. Swap problems
34.     Swap nodes in a linked list without swapping data
35.     Pairwise swap elements of a given linked list by changing links (TODO) [Swap nodes in pair]
36. Sorting
37.     Bubble Sort
38.     Insertion Sort
39.     Merge Sort
40.     Quick Sort
41.     Merge two sorted linked lists such that the resultant list is in reverse order
42.     Sort a Linked List of 0s, 1s and 2s.
43.     Rearrange list in zig zag fashion (TODO)
44.     Sort a linked list that is sorted alternating ascending and descending orders (TODO)
45. Convert a binary tree to DLL		|
46. Convert a DLL to Binary Tree		|	Very Very Important	
47.	Convert Sorted List to Binary Search Tree
48.	Convert BST to Sorted DLL
49. Find the N/K the node and squareRoot(n)th node.
50. Find the modulo node
51. Length of longest palindrome list in a linked list using O(1) extra space
52. Partitioning a linked list around a given value and keeping the original order
53. Rearrange a given list such that it consists of alternating minimum maximum elements
54. Flatten a multi-level linked list and its variations:
55.     Flatten a linked list and the output should be in sorted order
	    Node *flatten(Node *head){
        		if(head==NULL || head->right==NULL)
            		return head;
         		return merge(head, flatten(head->right));
	    }
56.     Flatten a multilevel linked list (level wise)
57.     Flatten a multilevel linked list (depth wise)
58.     Flatten Binary Tree to Linked List
59.     Flatten a Multilevel DLL
60. Josephus Circle using circular linked list
61. Construct a linked list from 2D matrix
62. Merge two Linked Lists:
	    Node* merge(Node *list1, Node *list2)
		    if(list1==NULL)	return list2;
		    if(list2==NULL) return list1;
    
		    if(list1->data <= list2->data)
		    	list1->next = merge(list1->next, list2);
		    	return list1;
		    else
		    	list2->next = merge(list1, list2->next);
		    	return list2;
63. Merge K sorted Lists
64. Intersection of two Linked Lists - Solve this without finding the length of the lists
65. Linked List Random Node
66. 
67. Reorder List
68. Populating Next Right Pointers in each Node.
69. Populating Next Right Pointers in each Node II.
70. Insertion Sort List
71. Plus One Linked List
72. Design Twitter
73. Design Phone Directory
74. LRU Cache
75. LFU Cache
76. All O(1) Data Structure
77. Design Circular Queue
78. Design HashSet
79. Design HashMap
80. Design LinkedList
81. Design Browser History
82. Design Skiplist
83. Design Front Middle Back Queue
84. Design Most Recently used Queue
85. Design Text Editor
86. Remove Zero Sum Consequtive nodes
87. Max Stack
88. Convert Binary Number in Linked List to Integer
89. Linked List in Binary Tree
90. Insert into Sorted Circular Linked List
91. Add Two Polynomials represented as Linked Lists
92. Merge In between Linked Lists
93. Split Linked Lists into Parts
94. Swapping Nodes in Linked List
95. Linked List components
96. Next Greater Node in Linked List
97. Spiral Matrix IV
98. Split a Circular Linked List.
99. Double a Number represented as Linked List
100. Convert DLL to Array I/II
101. Minimum Pair Removal to Sort Array I/II
