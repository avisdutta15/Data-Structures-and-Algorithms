1. Insertion, Deletion, Search, Rotate, Nth node from end.
2. Delete Problems
3.      Delete a LL
4.      Delete Alternate Nodes
5.      Delete Nodes which have greater value on right
6.      Delete N nodes after M nodes [IMP]
7.      Delete Last occurance of an element
8.      Remove duplicate elements from sorted (I/II)/unsorted linked list
9.      Delete a node in linked list when you are not passed the pointer to pointer to head i.e. (**head) and it should not return any pointer.
		    To handle the case when the node to be deleted is the first node, we copy the next node data to head and delete the next node.
10. Cycle Detection, Finding the first node of the cycle, Remove loop
11. Is Linked List pallindrome.
12. Odd Even List
13. Segregate odd and even positioned nodes
14. Partition List [TODO]
15. Reverse Problems
16.     Iterative reverse
17.     Recursive reverse
    	    reverse(current):
	        	if(current->next == NULL) //make last node as head node
			    head = current;
			    return;
		    reverse(current->next);
		    current->next->next = current;
		    current->next = NULL;
18.     Reverse List between index i and j.
19.     Reverse a Linked List in groups of given size [TODO]
20.     Reverse alternate K nodes in a Singly Linked List [TODO]
21.     Print Immutable Linked List in Reverse [TODO]
22.     Reverse Nodes in Even Length Groups [TODO]
23. Add two numbers represented by linked lists
24. Add two numbers represented by linked lists (II)
25. Mulitply two numbers represented by linked lists [TODO]
26. Clone a Linked List with random pointer (V VIP)
	    App1: Use Hash table
		HashTable (oldNode, corrsponding newNode)
		travese the linked list
			find the old node, check its random node through list
			find the random node in the hash table. join Hash[OldNode]->random = Hash[OldNode->random]

	    App2: Inserting new nodes in between
27. LinkedList Random Node (https://www.youtube.com/watch?v=FoHIX3URFaM) [TODO]
28. MergeSort Problems
29.     Merge Two Sorted Linked Lists
30.     Merge K Sorted Lists
31.     MergeSort    
32.     Find a triplet from three linked lists with sum equal to a given number   
33.     Sort linked list which is already sorted on absolute values [TODO] 
	        An important observation is, all negative elements are present in reverse order. 
	        So we traverse the list, whenever we find an element that is out of order, we move it to the front of linked list.
34.     Point to next higher value node in a linked list with an arbitrary pointer
            first attach the arbit pointer to next node using next pointer
                node->arbit = node->next
            sort the array using merge sort based on arbit pointer.
35. Swap problems
36.     Swap nodes in a linked list without swapping data
37.     Pairwise swap elements of a given linked list by changing links (TODO) [Swap nodes in pair]
38. Sorting
39.     Bubble Sort
40.     Insertion Sort
41.     Merge Sort
42.     Quick Sort
43.     Merge two sorted linked lists such that the resultant list is in reverse order
44.     Sort a Linked List of 0s, 1s and 2s.
45.     Rearrange list in zig zag fashion (TODO)
46.     Sort a linked list that is sorted alternating ascending and descending orders (TODO)
47. Convert a binary tree to DLL		|   [TODO]
48. Convert a DLL to Binary Tree		|	Very Very Important	
49.	Convert Sorted List to Binary Search Tree
50.	Convert BST to Sorted DLL
51. Find the N/K the node and squareRoot(n)th node.
52. Find the modulo node
53. Length of longest palindrome list in a linked list using O(1) extra space
54. Partitioning a linked list around a given value and keeping the original order
55. Rearrange a given list such that it consists of alternating minimum maximum elements
56. Flatten a multi-level linked list and its variations:
57.     Flatten a linked list and the output should be in sorted order
	    Node *flatten(Node *head){
        		if(head==NULL || head->right==NULL)
            		return head;
         		return merge(head, flatten(head->right));
	    }
58.     Flatten a multilevel linked list (level wise)
59.     Flatten a multilevel linked list (depth wise)
60.     Flatten Binary Tree to Linked List
61.     Flatten a Multilevel DLL
62. Josephus Circle using circular linked list
63. Construct a linked list from 2D matrix
64. Merge two Linked Lists:
	    Node* merge(Node *list1, Node *list2)
		    if(list1==NULL)	return list2;
		    if(list2==NULL) return list1;
    
		    if(list1->data <= list2->data)
		    	list1->next = merge(list1->next, list2);
		    	return list1;
		    else
		    	list2->next = merge(list1, list2->next);
		    	return list2;
65. Merge K sorted Lists
66. Intersection of two Linked Lists - Solve this without finding the length of the lists
67. Linked List Random Node
68. 
69. Reorder List
70. Populating Next Right Pointers in each Node.
71. Populating Next Right Pointers in each Node II.
72. Insertion Sort List
73. Plus One Linked List
74. Design Twitter
75. Design Phone Directory
76. LRU Cache
77. LFU Cache
78. All O(1) Data Structure
79. Design Circular Queue
80. Design HashSet
81. Design HashMap
82. Design LinkedList
83. Design Browser History
84. Design Skiplist
85. Design Front Middle Back Queue
86. Design Most Recently used Queue
87. Design Text Editor
88. Remove Zero Sum Consequtive nodes
89. Max Stack
90. Convert Binary Number in Linked List to Integer
91. Linked List in Binary Tree
92. Insert into Sorted Circular Linked List
93. Add Two Polynomials represented as Linked Lists
94. Merge In between Linked Lists
95. Split Linked Lists into Parts
96. Swapping Nodes in Linked List
97. Linked List components
98. Next Greater Node in Linked List
99. Spiral Matrix IV
100. Split a Circular Linked List.
101. Double a Number represented as Linked List
102. Convert DLL to Array I/II
103. Minimum Pair Removal to Sort Array I/II
